# 计网期中项目设计文档
写一个网络应用LFTP，该应用支持互联网中的两台计算机进行大文件传输

## 需求
1. 使用UDP协议传输，但要求像TCP一样完全可靠
### 实现方法：
使用回退N步（GBN）协议，允许发送方发送多个分组，而不需要等待确认。
UDP是不可靠传输的，它所收到的数据是无序的，也有可能在中途丢包。而在GBN协议中，接收方丢弃所有失序分组，确保其像TCP一样可靠。

2.  实现流控制
流控制，是让发送方的发送速率不要太快，让接收方来得及接受。
接收端维护一个接收缓存，每次处理数据之后，接收端把当前缓存的空闲空间的大小（rwnd)返回给发送端。发送端跟踪两个变量，LastByteSent和LastByteAcked，这两个值的差就是主机A发送到连接中但未被确认的数据量。发送端要将未确认的数据量控制在rwnd以内，以确保发送端不会使主机B的接收缓存溢出。
### 实现方法
我们在接收端使用一个队列来模拟接收缓存。因为我们用的python的socket接口，实际上socket.recvfrom(size)这个方法是从UDP接收缓存中获取size个字节的数据，缓存已经是有一个实现了的，通过sock.getsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF)我们可以知道它的大小为65536。但是这个应用中我们忽视这个底层真正的缓存，我们把真正的缓存里的内容当作是仍在网络中传输的数据包。

当接收方接收到数据包，回复ACK包时要把当前的rwnd值发送给发送方。而发送方根据这个值，将未确认的数据量控制在值rwnd内。


3. 实现阻塞控制
参照TCP的拥塞控制算法，应用实现了慢启动和拥塞避免。
通过维护一个变量拥塞窗口（cwnd），对发送方的发送流量的速率进行了限制。加上前面的流量控制，发送端必须满足
$$ LastByteSent - LastByteAcked <= min \{cwnd, rwnd \} $$
何时拥塞：当出现丢包的时候就假设出现网络拥塞的情况。
**慢启动**
设置初始cwnd为1，表示一个RTT内传送一个数据包。开始时应用向接收端发送一个数据包并等待确认，当收到确认包后，将cwnd值翻倍，指数增长。当检测到拥塞时，将慢启动阈值（ssthresh)设为cwnd值的一半，当到达或超过ssthresh值时，结束慢启动进行拥塞避免模式。
**拥塞避免**
此时距离拥塞可能并不遥远，因此不能每过一个RTT将cwnd的值翻番，而采用每次只增加1、当再次出现拥塞时，ssthresh的值被更新为原来的cwnd值的一半，然后将cwnd设为1，进入慢启动阶段。

4. 服务端要支持多个客户端同时在线
使用python的threading包。当检测到有用户连接到服务器时，为用户创建一个进程。

5. 程序要提供必要的出错反馈信息
 



